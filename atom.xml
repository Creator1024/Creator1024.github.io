<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>oneWay</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-10-08T03:29:44.837Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>oneWay</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SSR</title>
    <link href="http://yoursite.com/2018/10/08/SSR/"/>
    <id>http://yoursite.com/2018/10/08/SSR/</id>
    <published>2018-10-08T03:28:52.000Z</published>
    <updated>2018-10-08T03:29:44.837Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、工具准备"><a href="#一、工具准备" class="headerlink" title="一、工具准备"></a>一、工具准备</h3><ul><li>vps（以tx云主机做测试）  </li><li>xshell5  </li></ul><h3 id="二、具体步骤"><a href="#二、具体步骤" class="headerlink" title="二、具体步骤"></a>二、具体步骤</h3><h4 id="2-1-使用xshell连接到云主机"><a href="#2-1-使用xshell连接到云主机" class="headerlink" title="2.1.使用xshell连接到云主机"></a>2.1.使用xshell连接到云主机</h4><p>#<a href="http://www.downza.cn/soft/235505.html" target="_blank" rel="noopener">xshell5下载</a></p><h4 id="2-2-安装SSR服务端（root下）"><a href="#2-2-安装SSR服务端（root下）" class="headerlink" title="2.2.安装SSR服务端（root下）"></a>2.2.安装SSR服务端（root下）</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wget --no-check-certificate https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocksR.sh  </span><br><span class="line">chmod +x shadowsocksR.sh  </span><br><span class="line">./shadowsocksR.sh <span class="number">2</span>&gt;&amp;<span class="number">1</span> | tee shadowsocksR.log</span><br><span class="line">  </span><br><span class="line">//tee命令用于重定向到文件且输出结果</span><br></pre></td></tr></table></figure><p>接下来选择各种基础配置：  </p><ul><li>password——客户端连接服务器所用的密码（Default：teddysun.com）</li><li>port——服务器开放的端口号  </li><li>cipher——加密方式（Default: aes-256-cfb）  </li><li>protocol——协议（Default: origin） </li><li>obfs——混淆（Default: plain）  </li></ul><p>等几分钟后安装成功：<br><img src="https://upload-images.jianshu.io/upload_images/12329802-ecbbdd08e6ce97ba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h4 id="2-3-使用SSR客户端连接"><a href="#2-3-使用SSR客户端连接" class="headerlink" title="2.3.使用SSR客户端连接"></a>2.3.使用SSR客户端连接</h4><p>到网上下载一个SSR客户端，填写相应的信息即可连接。<br><img src="https://upload-images.jianshu.io/upload_images/12329802-6b64e637423a1b09.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h4 id="2-4-结果测试"><a href="#2-4-结果测试" class="headerlink" title="2.4.结果测试"></a>2.4.结果测试</h4><p>在服务器上查看连接状态，可以看到连接信息：<br><img src="http://upload-images.jianshu.io/upload_images/12329802-e3351164cbb6d7af.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image">  </p><p>使用香港或者国外的vps搭建后就能过GFW了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、工具准备&quot;&gt;&lt;a href=&quot;#一、工具准备&quot; class=&quot;headerlink&quot; title=&quot;一、工具准备&quot;&gt;&lt;/a&gt;一、工具准备&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;vps（以tx云主机做测试）  &lt;/li&gt;
&lt;li&gt;xshell5  &lt;/li&gt;
&lt;/ul&gt;
&lt;
      
    
    </summary>
    
      <category term="其他" scheme="http://yoursite.com/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="SSR" scheme="http://yoursite.com/tags/SSR/"/>
    
  </entry>
  
  <entry>
    <title>SSH</title>
    <link href="http://yoursite.com/2018/09/25/SSH/"/>
    <id>http://yoursite.com/2018/09/25/SSH/</id>
    <published>2018-09-25T03:22:12.000Z</published>
    <updated>2018-10-08T03:31:52.176Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h3 id="一、作用"><a href="#一、作用" class="headerlink" title="一、作用"></a>一、作用</h3><p>ssh（Security Shell）是用来实现安全远程管理的一个协议。相比于telnet，使用ssh能够有效地解决信息泄露的问题。</p><h3 id="二、算法及交互过程"><a href="#二、算法及交互过程" class="headerlink" title="二、算法及交互过程"></a>二、算法及交互过程</h3><p>ssh建立连接主要有以下五个步骤：<br>①协商ssh版本<br>②协商将要使用的各种算法<br>③通过Diffie-Hellman算法得到之后通信所使用的密钥<br>④认证阶段，服务器对客户端进行身份验证<br>⑤认证成功之后，客户端请求发起会话，服务器确认之后即可开始信息交互<br><img src="https://upload-images.jianshu.io/upload_images/12329802-d57b00be17b765fb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h4 id="2-1-协商ssh版本"><a href="#2-1-协商ssh版本" class="headerlink" title="2.1.协商ssh版本"></a>2.1.协商ssh版本</h4><p>①客户端向服务器发起连接请求，ssh协议基于TCP，默认端口为22<br>②服务器把自己的ssh协议版本号发送给客户端<br>③客户端知道了服务器所使用的版本后，选择相同或者能够兼容服务器的版本，将版本信息发送给服务器<br>④服务器判断是否支持客户端要使用的版本，如果支持，将进入算法和密钥的协商阶段，否则关闭此连接<br><img src="https://upload-images.jianshu.io/upload_images/12329802-6c130d7af2f0e29e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h4 id="2-2-算法协商"><a href="#2-2-算法协商" class="headerlink" title="2.2.算法协商"></a>2.2.算法协商</h4><p>①客户端发送自己支持的<strong>公钥算法列表</strong>，<strong>加密算法列表</strong>，<strong>MAC算法列表</strong>，<strong>压缩算法列表</strong><br><img src="https://upload-images.jianshu.io/upload_images/12329802-f2e03a1188bce20c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>②服务器回复ack报文确认，并发送自己支持的各种算法列表<br><img src="https://upload-images.jianshu.io/upload_images/12329802-b291c2d707f76934.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><img src="https://upload-images.jianshu.io/upload_images/12329802-12de138065b5c854.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>③双方开始协商要使用的各种算法，这里的协商<strong>以客户端为主</strong> ，按客户端各算法列表从左至右开始匹配（例如加密算法中，最左边的aes128-cbc的优先级是最高的），如果服务器支持相应的算法，则匹配成功，如果匹配到最后都不支持，则协商失败</p><h4 id="2-3-密钥协商"><a href="#2-3-密钥协商" class="headerlink" title="2.3.密钥协商"></a>2.3.密钥协商</h4><p>由于使用的是SSH2.0版本，会话密钥的协商方式使用Diffie-Hellman算法。这里简单地介绍一下这个算法：<br>Diffie-Hellman算法是Whitefield Diffie和Martin Hellman在1976年公布的一种<strong>密钥交换算法</strong>，它的有效性依赖于计算离散对数的难度<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; 现客户端A要和服务器B交换密钥：</span><br><span class="line">&gt; 服务器B规定一个素数P，一个整数G，G是P的原根</span><br><span class="line">&gt; 客户端生成自己的私用密钥a（a&lt;q），并计算公开密钥e=G^a mod P，把e发送给服务器B</span><br><span class="line">&gt; 服务器生成自己的私用密钥b（b&lt;q），并计算公开密钥f=G^b mod P，把f发送给客户端A</span><br><span class="line">&gt; 客户端A可以通过自己的私用密钥a和服务器的公开密钥f算出共享密钥 K=f^a mod P</span><br><span class="line">&gt; 服务器B可以通过自己的私用密钥b和客户端的公开密钥e算出共享密钥 K=e^b mod P</span><br><span class="line">&gt; </span><br><span class="line">&gt; 二者计算的结果K值是一致的，从而完成了密钥交换</span><br><span class="line">&gt; a和b对其他人是保密的，攻击者只能离散对数来确定密钥</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>大致协商过程如下，由客户端首先发起请求<br><img src="https://upload-images.jianshu.io/upload_images/12329802-9aee6fcc98eb313c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><strong>①</strong>客户端发出的第一个报文说明了密钥交互参数：Min、Number of Bits、Max<br><img src="https://upload-images.jianshu.io/upload_images/12329802-b9c4ed7623def0f3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><strong>②</strong>服务器端收到客户端DH请求后，设定P和G发送给客户端，P是一个大素数，满足客户端刚刚发来的那些要求，G是大于1的数，通常取2或者5<br><img src="https://upload-images.jianshu.io/upload_images/12329802-ee171f025fbc4830.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><strong>③</strong>客户端收到P和G后，生成自己的私钥a，并根据a计算出自己的公钥e，并把e发送给服务器端<br><img src="https://upload-images.jianshu.io/upload_images/12329802-4f1d9af5e2bc322e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><strong>④</strong>服务器也会生成自己的私钥b并计算出公钥f，收到客户端发来的e后，利用b和e生成共享密钥K，接着把f发给客户端，用于客户端计算共享密钥K<br><img src="https://upload-images.jianshu.io/upload_images/12329802-3dcf0524979736f1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>KEX DH host key是服务器的主机公钥（通常是RSA）<br>KEX DH H Signature是服务器用主机私钥对计算出的哈希值H进行签名的结果<br>H的值是将客户端初始报文、服务器初始报文、客户端DH公钥、服务器DH公钥等参数进行哈希的结果  </p><p><strong>⑤</strong>客户端接受到f之后，计算出共享密钥K，然后服务器一样计算出H的值，并用服务器的公钥解密KEX DH H Signature，将结果与自己计算的H值比较，如果一致，就会向服务器发送New Keys报文，双方密钥交换成功。计算出的H作为会话ID，K作为之后通信过程中的加密密钥</p><p><img src="https://upload-images.jianshu.io/upload_images/12329802-08e1b02017f78e90.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h4 id="2-4-认证及交互阶段"><a href="#2-4-认证及交互阶段" class="headerlink" title="2.4.认证及交互阶段"></a>2.4.认证及交互阶段</h4><p>共享密钥协商成功之后，数据报文都被加密，只能看到加密后的结果：<br><img src="https://upload-images.jianshu.io/upload_images/12329802-2d7bbd365d707c62.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>认证方式有两种：</p><ul><li>用户名密码认证<br><strong>①</strong>客户端发起认证请求，服务器回复其公钥<br><strong>②</strong>客户端使用服务器的公钥将其用户名密码加密后发给服务器<br><strong>③</strong>服务器使用自己的私钥解密，验证结果</li><li>公钥私钥认证<br><strong>①</strong>客户端发送登录的ip和用户名，服务器识别该客户端的公钥（在authorized_keys文件中），利用该公钥加密一段随机字符串发送刚给客户端<br><strong>②</strong>客户端使用私钥解密，得到随机字符串后发送给服务器<br><strong>③</strong>服务器收到该字符串，若与其之前生成的一致，即说明公私钥匹配，认证成功<br>注：要使用该认证方式需要事先在客户端生成公私钥，并把公钥存放在服务器上</li></ul><h3 id="三、SSH相关应用"><a href="#三、SSH相关应用" class="headerlink" title="三、SSH相关应用"></a>三、SSH相关应用</h3><h4 id="3-1-Linux的下ssh"><a href="#3-1-Linux的下ssh" class="headerlink" title="3.1.Linux的下ssh"></a>3.1.Linux的下ssh</h4><p>linux系统中，一般默认都安装了ssh客户端及服务端。ssh服务的相关进程是<strong>sshd</strong>，可以使用<strong>servcie sshd status</strong>(CentOS6)查看当前该服务的运行状态。</p><h5 id="3-1-1-ssh-client"><a href="#3-1-1-ssh-client" class="headerlink" title="3.1.1.ssh  client"></a>3.1.1.ssh  client</h5><ul><li>最简单的登录：ssh user@ip，如ssh <a href="mailto:root@1.1.1.1" target="_blank" rel="noopener">root@1.1.1.1</a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; ssh命令有关参数：</span><br><span class="line">&gt; -A：开启认证代理连接转发功能</span><br><span class="line">&gt; -a：关闭认证代理连接转发功能</span><br><span class="line">&gt; -b：使用本地指定地址作为对应连接的源ip</span><br><span class="line">&gt; -f：后台执行ssh指令</span><br><span class="line">&gt; -i：指定身份文件</span><br><span class="line">&gt; -p：指定远程服务器端口</span><br><span class="line">&gt; -N：不执行远程指令</span><br><span class="line">&gt; </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul></blockquote><blockquote><ul><li>如果远程服务器默认端口不是22（可以设置一个高位端口，比如10024），则需要指定端口：ssh user@ip -p 10024</li></ul><p>如果我们要经常使用某个远程主机，可以通过配置$HOME/.ssh/config文件更方便地进行连接<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; vim ~/.ssh/config  #当前是root用户</span><br><span class="line">&gt; Host test</span><br><span class="line">&gt;     StrictHostKeyChecking no  #第一次连接新的主机时，自动接收公钥，无需提示。</span><br><span class="line">&gt;     HostName 1.1.1.1</span><br><span class="line">&gt;     Port 22</span><br><span class="line">&gt;     ForwardAgent yes   </span><br><span class="line">&gt;     User root</span><br><span class="line">&gt;     Controlpath ~/.ssh/ssh-%r@%h:%p.sock</span><br><span class="line">&gt; </span><br><span class="line">&gt; 以后只需要ssh test即可.</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>ssh客户端的读取顺序如下<br>①命令行<br>②$HOME/.ssh/config<br>③/etc/ssh/ssh_config（所有用户使用的配置文件）</p><h5 id="3-1-2-ssh-server"><a href="#3-1-2-ssh-server" class="headerlink" title="3.1.2. ssh server"></a>3.1.2. ssh server</h5><p>配置文件：/etc/ssh/sshd_config<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; Port 22    #ssh监听的端口，可以写多个</span><br><span class="line">&gt; ListenAddress 10.104.45.112   #可以指定监听的具体地址，默认是注释的，表示监听0.0.0.0</span><br><span class="line">&gt; Protocol 2   #使用sshv2</span><br><span class="line">&gt; PasswordAuthentication yes    #密码认证</span><br><span class="line">&gt; X11Forwarding yes   #允许本地主机上执行远程主机的GUI程序</span><br><span class="line">&gt; PermitRootLogin yes  #允许root登录</span><br><span class="line">&gt; AllowUsers xxx #只允许xxx用户登录的用户</span><br><span class="line">&gt; ...</span><br><span class="line">&gt; </span><br><span class="line">&gt; 修改完配置文件之后，需要重启服务才能生效</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><h4 id="3-2-利用ssh反向代理访问内网主机"><a href="#3-2-利用ssh反向代理访问内网主机" class="headerlink" title="3.2.利用ssh反向代理访问内网主机"></a>3.2.利用ssh反向代理访问内网主机</h4><p>如果要远程访问一台内网主机，有两种方式：</p><ul><li>通过静态NAT或PAT将内网主机的地址/端口映射到公网</li><li>借助一台公网服务器，利用ssh反向代理来访问内网主机<h5 id="3-2-1-方法一：静态NAT或PAT"><a href="#3-2-1-方法一：静态NAT或PAT" class="headerlink" title="3.2.1.方法一：静态NAT或PAT"></a>3.2.1.方法一：静态NAT或PAT</h5>一般只有企业的网络管理员能使用这种方法，可以通过静态NAT将内网主机的地址转化为一个公网地址（一般拥有大量公网地址才会这么做），或者使用PAT将内网主机的端口映射到公网地址的某个端口，这里就简单地给出路由器上的配置：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment">#静态NAT：将内网主机地址192.168.1.100映射为公网地址1.1.1.1</span></span><br><span class="line">&gt; Cisco Router：</span><br><span class="line">&gt; ip nat inside source static <span class="number">192.168</span><span class="number">.1</span><span class="number">.100</span> <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span> </span><br><span class="line">&gt; HuaWei Router：</span><br><span class="line">&gt; nat static <span class="keyword">global</span> <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span> inside <span class="number">192.168</span><span class="number">.1</span><span class="number">.100</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment">#PAT：内网主机的22端口映射到公网地址22122端口</span></span><br><span class="line">&gt; Cisco Router：</span><br><span class="line">&gt; ip nat inside source static tcp <span class="number">192.168</span><span class="number">.1</span><span class="number">.100</span> <span class="number">22</span> <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span> <span class="number">22122</span> </span><br><span class="line">&gt; HuaWei Router：</span><br><span class="line">&gt; nat static protocol tcp <span class="keyword">global</span> current-interface <span class="number">22122</span> inside <span class="number">192.168</span><span class="number">.1</span><span class="number">.100</span> <span class="number">22</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul></blockquote><blockquote><h5 id="3-2-2-方法二：ssh反向代理"><a href="#3-2-2-方法二：ssh反向代理" class="headerlink" title="3.2.2.方法二：ssh反向代理"></a>3.2.2.方法二：ssh反向代理</h5><p>大部分情况下，我们无法管理公网地址，接下来介绍第二种方法，此方法需要借助一台公网服务器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; 公网主机A： ip——1.1.1.1  sshd端口——22</span><br><span class="line">&gt; 内网主机B： ip——192.168.1.100  sshd端口——22</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>首先在内主机B上：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; ssh -NfR 6666:localhost:22 root@1.1.1.1 </span><br><span class="line">&gt; 将A的6666端口和B的22端口绑定</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>接着在外网主机A上：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; netstat -ano | grep 1234</span><br><span class="line">&gt; tcp  0  0 127.0.0.1:1234     0.0.0.0:*    LISTEN  off (0.00/0/0)</span><br><span class="line">&gt; 可以看到本地在监听1234端口</span><br><span class="line">&gt; 接着使用以下命令就可以从公网主机A上访问内网主机B了</span><br><span class="line">&gt; ssh localhost -p 1234</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>通过以上方式，已经可以实现我们的需求，接下来可以做一些优化：</p><ul><li>使用公私钥登录，无需在登录的时候输入密码<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; 第一步：在内网服务器B上生成公私钥</span><br><span class="line">&gt; ssh-keygen -t rsa   #一直按回车，使用默认选项即可</span><br><span class="line">&gt; 成功后在~/.ssh/目录下就会生成id_rsa（私钥）和id_rsa.pub （公钥文件）</span><br><span class="line">&gt; </span><br><span class="line">&gt; 第二步：将B的公钥放到外网主机A的~/.ssh/authorized_keys</span><br><span class="line">&gt; ssh root@1.1.1.1 &apos;mkdir -p ~/.ssh &amp;&amp; cat &gt;&gt; .ssh/authorized_keys&apos; &lt; ~/.ssh/id_rsa.pub</span><br><span class="line">&gt; 或者使用</span><br><span class="line">&gt; ssh-copy-id root@1.1.1.1</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul></blockquote><blockquote><ul><li>使用autossh维护反向连接<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; yum install -y autossh</span><br><span class="line">&gt; ...</span><br><span class="line">&gt; autossh -M 8888 -NR 1234:localhost:22 root@1.1.1.1 -p 22</span><br><span class="line">&gt; autossh的命令跟ssh差不多，默认后台运行，所以无需加-f</span><br><span class="line">&gt; -M选项表示维护程序监听8888端口，保证连接的可用性，如果断掉，则会重新连接</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;h3 id=&quot;一、作用&quot;&gt;&lt;a href=&quot;#一、作用&quot; class=&quot;headerlink&quot; title=&quot;一、作用&quot;&gt;&lt;/a&gt;一、作用&lt;/h3&gt;&lt;p&gt;ssh（Security Shell）是用来实现安全远程管理的一个协议。相比于telnet，使用s
      
    
    </summary>
    
      <category term="数据通信" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/"/>
    
      <category term="协议分析" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/"/>
    
    
      <category term="SSH" scheme="http://yoursite.com/tags/SSH/"/>
    
  </entry>
  
  <entry>
    <title>DHCP</title>
    <link href="http://yoursite.com/2018/09/22/DHCP/"/>
    <id>http://yoursite.com/2018/09/22/DHCP/</id>
    <published>2018-09-22T03:24:35.000Z</published>
    <updated>2018-10-08T03:26:05.920Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、作用"><a href="#一、作用" class="headerlink" title="一、作用"></a>一、作用</h3><p>dhcp（Dynamic Host Configuration Protocol）用于主机自动获取ip地址、网关以及dns等配置。其基于C/S的架构，服务器默认监听UDP67端口，客户端默认监听UDP68端口。</p><h3 id="二、操作过程"><a href="#二、操作过程" class="headerlink" title="二、操作过程"></a>二、操作过程</h3><p>主机向dhcp服务器请求获取配置有4个步骤：<br>①主机发出一个dhcp discover广播报文，请求获取配置信息<br>②服务器收到请求后回复dhcp offer报文，包含相关配置信息<br>③主机发送dhcp request报文，向服务器确认自己将要使用分配的ip地址<br>④服务器回复ack，客户端确认使用该地址，整个过程结束</p><p><img src="https://upload-images.jianshu.io/upload_images/12329802-1e856d9fdc418280.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图1"><br>以此拓扑为例，Host1和DHCP Server（R2）不在同一个网段，所以需要在R1的e0/0接口上配置dhcp中继，现主机请求通过dhcp获取ip地址等信息<br><img src="https://upload-images.jianshu.io/upload_images/12329802-68370528a6814762.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图2：Host1上抓包信息"></p><p><img src="https://upload-images.jianshu.io/upload_images/12329802-22fc3d9f07df22a2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图3：R2上抓包信息"></p><ul><li>DHCP Discover<br>Discover报文<strong>源ip为0.0.0.0</strong>，<strong>源mac为Host1的mac地址</strong>，因为此时主机没有ip地址，<strong>目的ip为255.255.255.255广播地址</strong>，<strong>目的mac为全f的二层广播地址</strong>，同一个局域网内的dhcp服务器均能接收到该主机的dhcp请求。R1的e0/0接口配置了dhcp中继，并且能够到达R2（不同网段的DHCP服务器），所以R1就是一台192.168.1.0网段里的dhcp服务器，他转发各种dhcp报文到R2，图2和图3中dhcp消息内，除了Hops（表明经过了多少跳到达dhcp服务器）和Relay agent IP address（dhcp中继的ip地址）不一样外，其他均一致，如图4和图5所示：<br><img src="https://upload-images.jianshu.io/upload_images/12329802-827df4e07ddead29.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图4"><br><img src="https://upload-images.jianshu.io/upload_images/12329802-ea419c54f4da49d6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图5"><br>注意：dhcp中继（R1）和dhcp服务器（R2）都是使用67端口进行通信</li></ul><p>该报文中各个选项字段说明了DHCP消息类型，客户端标识，主机名，请求列表等信息<br><img src="https://upload-images.jianshu.io/upload_images/12329802-d14e0e4bd1dc1880.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图6：Discover报文中选项字段"></p><ul><li><p>DHCP Offer<br>服务器接收到Discover报文之后，如果本地地址池能够提供ip，则回复Offer报文。<strong>源IP/MAC为dhcp服务器ip/mac</strong>，由于此时主机还没有ip，<strong>目的IP/MAC为广播</strong>。<br><img src="https://upload-images.jianshu.io/upload_images/12329802-599b3f927277d153.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图7：Offer报文"><br>其中，your IP address就是服务器分配给主机的ip地址，其他相关的配置在Option字段中给出。</p></li><li><p>DHCP Request<br>主机接收到DHCP Offer消息后，确定自己要使用这些配置，就会发送Request报文。由于局域网中可能不止存在一台dhcp服务器，当主机发送discover报文之后，可能会收到多个Offer报文，一般主机会选择最先接收到的那个，在这个时候，主机不会马上使用这些配置，故<strong>源IP为0.0.0.0，目的IP/MAC为广播</strong>，个人认为这个Offer消息有两个作用，其一是用来告诉同网段内的所有dhcp服务器自己要选择哪个dhcp服务器，其二是告诉提供给自己所使用的Offer报文的那个服务器，我已经收到你的Offer消息，并确认要使用这个地址，你可以把这个ip从地址池中删除了。假如服务器是只发出Offer消息就认为所提供的ip会被使用，那我们发送几百个Discover之后ip地址池可能就被耗尽了<br><img src="https://upload-images.jianshu.io/upload_images/12329802-e66c7d9feccbf85f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图7：Request报文"></p></li><li><p>DHCP ACK<br>服务器收到Request之后，检查地址池，确认该地址可用后回复ACK报文。主机接收到该报文之后，才真正的使用服务器提供的地址。所以ACK报文的<strong>目的IP/MAC都是广播</strong><br><img src="https://upload-images.jianshu.io/upload_images/12329802-21b26432b88ec88a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图8：ACK报文"></p></li></ul><p>至此，Host1获取到了DHCP服务器（R2）所提供的IP地址192.168.1.1，配置好IP地址之后，会针对该地址发送免费ARP，以确认该网段中没有其他地址冲突，由于本例中dhcp服务器上没有将192.168.1.1地址给排除，导致主机获取到了该地址，与R1的e0/0口地址冲突，这时候Host1发送一个DHCP Decline报文，并开始新的一轮dhcp地址请求过程，最后请求到192.168.1.2<br><img src="https://upload-images.jianshu.io/upload_images/12329802-a33071a1e2c90d66.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图9"></p><p>总结一下本例中遇到的DHCP报文类型并补充一些没有涉及到的类型：<br>| Type     | 作用                                                         |<br>| ——– | ———————————————————— |<br>| Discover | 客户端发起DHCP请求获取IP地址等配置信息                       |<br>| Offer    | dhcp服务器提供相关配置信息给客户端                           |<br>| Request  | 客户端确认要使用第一个Offer提供的IP地址，发送Request广播消息。此外，客户端下次开机的时候只需要发送Request消息而无需再发Discover消息重新请求一遍 |<br>| ACK      | 服务器接收到Request后确认IP地址可以使用，回复ACK             |<br>| NACK     | 服务器接收到Request后发现由于某些原因IP地址无法使用，回复NACK |<br>| Release  | 用户不需要分配的IP地址时，向服务器发送Release消息释放该被绑定的租约 |<br>| Decline  | 客户端收到ACK后，发现该IP地址与同网段内其他主机的地址发生冲突，回复Decline，并重新发生Discover再次请求 |<br>| Inform   | 客户端需要从服务器获取更详细的信息时发送Inform报文，服务器回复ACK |</p><h4 id="三、其他"><a href="#三、其他" class="headerlink" title="三、其他"></a>三、其他</h4><ul><li>DHCP饥饿攻击与防护<br>顾名思义，这种攻击手段通过伪造大量的mac地址在短时间内发送大量dhcp请求，把dhcp服务器的地址池资源耗尽，之后可以在网络中放置一台非法dhcp服务器，从而给其他主机下发攻击者自定义的配置信息。可以通过交换机上配置端口安全，限制mac地址数量以及DHCP snooping技术（限制交换机端口接收offer报文）来防止此类攻击</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、作用&quot;&gt;&lt;a href=&quot;#一、作用&quot; class=&quot;headerlink&quot; title=&quot;一、作用&quot;&gt;&lt;/a&gt;一、作用&lt;/h3&gt;&lt;p&gt;dhcp（Dynamic Host Configuration Protocol）用于主机自动获取ip地址、网关以及dns等
      
    
    </summary>
    
      <category term="数据通信" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/"/>
    
      <category term="协议分析" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/"/>
    
    
      <category term="DHCP" scheme="http://yoursite.com/tags/DHCP/"/>
    
  </entry>
  
  <entry>
    <title>DNS Tunnel</title>
    <link href="http://yoursite.com/2018/09/02/DNSTunnel/"/>
    <id>http://yoursite.com/2018/09/02/DNSTunnel/</id>
    <published>2018-09-02T02:02:51.000Z</published>
    <updated>2018-10-08T03:24:59.730Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一-原理"><a href="#一-原理" class="headerlink" title="一.原理"></a>一.原理</h4><h5 id="1-1-dns概述"><a href="#1-1-dns概述" class="headerlink" title="1.1.dns概述"></a>1.1.dns概述</h5><p>dns协议最基本的作用是将域名映射为ip地址，让我们在访问网页的时候无需记住复杂的ip地址。<br>在一些地方，需要我们认证才能上网。假如我们没有认证，大部分的流量都会被过滤，但是往往都会放行dns流量，windows下可通过nslookup或者ping命令查看dns流量是否被过滤：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">C:\&gt;nslookup</span><br><span class="line">默认服务器:  UnKnown</span><br><span class="line">Address:  2001:250:6801:5501:2e0:4cff:fe51:c4</span><br><span class="line">&gt; baidu.com</span><br><span class="line">服务器:  UnKnown</span><br><span class="line">Address:  2001:250:6801:5501:2e0:4cff:fe51:c4</span><br><span class="line">非权威应答:</span><br><span class="line">名称:    baidu.com</span><br><span class="line">Addresses:  123.125.115.110          //能够返回ip地址则说明dns流量没有被过滤</span><br><span class="line">          220.181.57.216</span><br><span class="line"></span><br><span class="line">C:\&gt;ping baidu.com     </span><br><span class="line">正在 Ping baidu.com [220.181.57.216] 具有 32 字节的数据:</span><br><span class="line">//如果没有认证，一般icmp流量也会被禁用，但是我们可以看到域名成功解析为ip地址，则dns流量没有被过滤。</span><br></pre></td></tr></table></figure></p><p>如果放行了dns流量，就可以使用dns隧道免费上网。在我们学校，可以突破晚上十一点断网的限制，如果对网速没什么要求，连网费都可以不用交。</p><h5 id="1-2-dns隧道原理"><a href="#1-2-dns隧道原理" class="headerlink" title="1.2.dns隧道原理"></a>1.2.dns隧道原理</h5><ul><li>dns隧道工具将进入隧道的其他协议流量封装到dns协议内，在隧道上传输。这些数据包出隧道时进行解封装，还原数据。</li><li>在建立隧道之前，我们需要让dns隧道的客户端找到隧道的服务端，其过程大致如下：<br>①本地主机A发送一条dns请求，查询一个我们设定好的域名。<br>②因为沿途的dns服务器都没有这个域名的相关信息，最终这条请求被转发到权威域名服务器B（假如是腾讯云上注册的域名，腾讯的域名服务器就是针对你的域名的权威服务器）。<br>③我们添加了一条NS记录，关于要查询的域名，需要转到我们的公务服务器C做解析，B就会把C的地址返回给A。<br>④A知道了C的地址，就可以建立起dns隧道了。<br><img src="https://upload-images.jianshu.io/upload_images/12329802-5fb1a0665b5fce61.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li></ul><h3 id="二-实现步骤"><a href="#二-实现步骤" class="headerlink" title="二.实现步骤"></a>二.实现步骤</h3><h5 id="2-1-工具准备"><a href="#2-1-工具准备" class="headerlink" title="2.1.工具准备"></a>2.1.工具准备</h5><ul><li>一个域名</li><li><p>一台公网服务器，并且拥有公网地址。学生认证过的腾讯云或者阿里云上都可以买到10元/月的云服务器，域名也很便宜。<br><a href="https://cloud.tencent.com/act/campus" target="_blank" rel="noopener">学生优惠套餐</a><br><a href="https://cloud.tencent.com/act/free" target="_blank" rel="noopener">腾讯云个人免费体验15天云服务器</a><br><a href="https://cloud.tencent.com/act/domainsales" target="_blank" rel="noopener">域名注册</a></p></li><li><p>dns隧道工具：这里使用<a href="https://code.kryo.se/iodine/" target="_blank" rel="noopener">iodine</a>（拥有速度快、支持多平台等特点）</p></li><li>代理工具ssr、Proxifier，隧道搭建好之后，需要使用代理，让我们的应用程序走代理才能利用该隧道</li></ul><h5 id="2-2-添加域名解析"><a href="#2-2-添加域名解析" class="headerlink" title="2.2.添加域名解析"></a>2.2.添加域名解析</h5><p>我申请的域名是slickghost.com<br>a.slickghost.com和b.slickghost.com都是子域名（三级域名）<br>这里需要添加两条记录：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">主机记录           记录类型            记录值</span><br><span class="line">b                   A              云主机公网IP</span><br><span class="line">a                   NS           b.slickghost.com</span><br></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/12329802-01d0d4f7107dbd81.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>两条记录组合的含义如下：<br>当我们的主机去查询a.slickghost.com时，由于该域名对应的是一条NS记录，记录值是b.slickghost.com，此时，dns查询请求就会转发到b.slickghost.com这个域名服务器，而这个域名对应一条A记录，该记录值为云主机的公网地址，所以最终dns查询请求最会转发到我们的服务器。</p><h5 id="2-3-安装iodine"><a href="#2-3-安装iodine" class="headerlink" title="2.3.安装iodine"></a>2.3.安装iodine</h5><p><a href="https://code.kryo.se/iodine/" target="_blank" rel="noopener">iodine（点击下载）</a>是一个集成客户端和服务端的工具。这里使用的服务端为linux，客户端为windows，要下载两个版本。<br><img src="https://upload-images.jianshu.io/upload_images/12329802-3abaa80a62bcaf78.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h6 id="2-3-1-iodine服务端"><a href="#2-3-1-iodine服务端" class="headerlink" title="2.3.1.iodine服务端"></a>2.3.1.iodine服务端</h6><p><img src="https://upload-images.jianshu.io/upload_images/12329802-b1776839c4125623.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>服务器直接使用wget下载即可，如果有问题，可以先下载好压缩包再传到服务器上。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wget https://code.kryo.se/iodine/iodine<span class="number">-0.7</span><span class="number">.0</span>.tar.gz  //下载iodine</span><br><span class="line">tar -zxvf iodine<span class="number">-0.7</span><span class="number">.0</span>.tar.gz  //解压</span><br><span class="line">cd iodine<span class="number">-0.7</span><span class="number">.0</span>  //解压后进入该目录</span><br><span class="line">make install //安装</span><br></pre></td></tr></table></figure></p><p>安装后之后就会出现一个bin目录，该目录下有两个iodine应用程序，iodine（客户端）和iodined（服务端）。<br><img src="https://upload-images.jianshu.io/upload_images/12329802-a4aa6f0903ab090d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">接着运行命令：</span><br><span class="line">./iodined -f -c -P Password123 <span class="number">192.168</span><span class="number">.0</span><span class="number">.1</span> a.slickghost.com &amp;</span><br><span class="line"></span><br><span class="line">参数说明：</span><br><span class="line">-f to keep running <span class="keyword">in</span> foreground</span><br><span class="line">-c to disable check of client IP/port on each request  </span><br><span class="line">-P password used <span class="keyword">for</span> authentication (max <span class="number">32</span> chars will be used)</span><br><span class="line">Password123就是客户端连接服务器时需要用到的密码</span><br></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/12329802-a3b52ae0dcb7db00.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>此时DNS隧道服务端就部署完成了，等待客户端的连接。<br>可以使用iodine官方提供的工具测试服务端是否搭建成功：<a href="https://code.kryo.se/iodine/check-it/" target="_blank" rel="noopener">测试工具</a></p><h6 id="2-3-1-iodine客户端"><a href="#2-3-1-iodine客户端" class="headerlink" title="2.3.1.iodine客户端"></a>2.3.1.iodine客户端</h6><p>客户端需要一个TAP网卡，下载一个六快拨或者openvpn，安装完之后就会多出一块网卡。<br><a href="http://www.6kuaibo.com/index.html" target="_blank" rel="noopener">六快拨下载地址</a></p><p>解压windows版iodine后在<strong>管理员模式下</strong>运行命令：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iodine -P Password123 -f 公网地址 a.slickghost.com</span><br></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/12329802-73f21c944e5712df.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>至此，DNS隧道就搭建完成了。这时候应该要能够ping通刚刚我们在服务器指定的IP：192.168.0.1。<br><img src="https://upload-images.jianshu.io/upload_images/12329802-eecc0a65eb016984.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>创建dns隧道客户端时，其与服务端协商，并自动帮我们配置好了TAP网卡的IP地址。<br><img src="https://upload-images.jianshu.io/upload_images/12329802-ac71cf78e3cf31e9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>刚刚ping的时候使用的就是这个虚拟网卡。<br><img src="https://upload-images.jianshu.io/upload_images/12329802-4764c0b3fa57e954.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h5 id="2-4-使用代理"><a href="#2-4-使用代理" class="headerlink" title="2.4.使用代理"></a>2.4.使用代理</h5><p>我们已经把dns隧道搭建好了。但是现在应用程序的流量没有被指定通过这个隧道来走，我们使用<strong>ssr全局代理+Proxifier</strong>来解决这个问题。</p><h6 id="2-4-1-服务器安装ssr"><a href="#2-4-1-服务器安装ssr" class="headerlink" title="2.4.1.服务器安装ssr"></a>2.4.1.服务器安装ssr</h6><p>具体安装步骤参照：<a href="https://www.jianshu.com/p/a944c918ca24" target="_blank" rel="noopener">ssr搭建教程</a></p><h6 id="2-4-2-客户端ssr设置"><a href="#2-4-2-客户端ssr设置" class="headerlink" title="2.4.2.客户端ssr设置"></a>2.4.2.客户端ssr设置</h6><p>网上下载一个ssr客户端，进行如下配置<br><img src="https://upload-images.jianshu.io/upload_images/12329802-155bc2c4324247f3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>服务器ip是使用iodine创建隧道服务端时指定的ip。<br>服务器端口是安装ssr服务端时指定的端口。<br>将客户端ssr设置为<strong>全局代理</strong>之后，浏览器就可以绕过认证上网了。</p><h6 id="2-4-2-Proxifier设置"><a href="#2-4-2-Proxifier设置" class="headerlink" title="2.4.2.Proxifier设置"></a>2.4.2.Proxifier设置</h6><p>ssr只能让我们使用浏览器访问网页的时候绕过认证，其他的应用程序还是不能上网，我们需要用Proxifier将本地应用程序的流量转到ssr代理，从而能够利用dns隧道。</p><p>打开Proxifier之后，会自动检测可走ssr代理：<br><img src="https://upload-images.jianshu.io/upload_images/12329802-280fcd875afec07a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>点击确定后就会自动创建一个规则——直连到SSR<br>若检测不到，我们可以手动创建：配置文件——代理规则——添加。<br><img src="https://upload-images.jianshu.io/upload_images/12329802-c8d97f0040f42059.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>这时候电脑所有的应用程序都通过Proxifier走ssr代理，而原来我们的浏览器已经走ssr代理了，导致冲突，需要再添加一条规则，让你用到的浏览器不需要通过Proxifier。我平时使用的是firefox<br><img src="https://upload-images.jianshu.io/upload_images/12329802-ed13d683f33e6b65.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>添加好以上两条规则之后，所有的应用程序就都可以上网了。<br>登个tim，听听音乐，刷个网页啥还是没问题的。如果你的隧道服务器在香港或者国外，还可以过GFW。<br><img src="https://upload-images.jianshu.io/upload_images/12329802-ffb942d75fedbb3a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;一-原理&quot;&gt;&lt;a href=&quot;#一-原理&quot; class=&quot;headerlink&quot; title=&quot;一.原理&quot;&gt;&lt;/a&gt;一.原理&lt;/h4&gt;&lt;h5 id=&quot;1-1-dns概述&quot;&gt;&lt;a href=&quot;#1-1-dns概述&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
      <category term="其他" scheme="http://yoursite.com/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="DNS" scheme="http://yoursite.com/tags/DNS/"/>
    
  </entry>
  
  <entry>
    <title>DNS</title>
    <link href="http://yoursite.com/2018/09/01/DNS/"/>
    <id>http://yoursite.com/2018/09/01/DNS/</id>
    <published>2018-09-01T02:01:51.000Z</published>
    <updated>2018-10-08T03:31:01.489Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、作用"><a href="#一、作用" class="headerlink" title="一、作用"></a>一、作用</h3><p>现在互联网上绝大多数设备是基于TCP/IP协议，使用IP地址进行通信的。设备之间通信时必须要有一个IP地址。当我们需要访问一个网站时，相对于一个32bit的ip地址，我们更愿意记住一串更具标识性字符。而DNS协议最基本的作用便是把这串字符解析为相应的ip地址。</p><h3 id="二、域名系统"><a href="#二、域名系统" class="headerlink" title="二、域名系统"></a>二、域名系统</h3><h5 id="2-1-名称空间"><a href="#2-1-名称空间" class="headerlink" title="2.1.名称空间"></a>2.1.名称空间</h5><p>DNS中使用的所有的名称集合构成了DNS名称空间。与linux文件系统类似，这个名称空间是一个树形结构。<br>树根的顶部未命名，最高层（一级域）是顶级域名.（TLD），如我们常见的.com，.net（gTLD）就是属于顶级域名。</p><p><img src="https://upload-images.jianshu.io/upload_images/12329802-76d09433fc574b55.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>一个域名包含一系列的由点隔开的<strong>标签</strong>，每个标签最多可到63个字符，标签使用<strong>“Punycode码”</strong>编码。2017年的时候国内的安全专家发现部分浏览器会受到<a href="https://blog.csdn.net/qq_27446553/article/details/70255763" target="_blank" rel="noopener">Punycode钓鱼攻击</a>的影响。</li><li><p>标签类型有两种：数据标签和压缩标签。</p><ul><li>数据标签写法：<strong>[3]www[7]jianshu[3]com[0]</strong>——标签长度+字符，根标签长度为0。</li><li>压缩标签：当有多条其中一部分内容一样的记录时，压缩标签可以通过指向其他标签的指针以节省dns信息空间。比如说<strong>[3]usc[3]edu[0][4]ucla[192][4][0]</strong> ——设置标签内容之前的一个字节的2个高位为1（也就是192）来标识这是一个压缩标签，之后的14位（6+8）用来标识偏移量（本例中偏移量位4），则[192][4]就相当于edu。usc.edu和ucla.edu就共享了edu标签。</li></ul></li><li><p>我们通常看到的域名都是<strong>完全限定域名</strong>（fully qualified domain name，FQDN）——主机名+全路径。</p></li><li>区域——一个区域是DNS名称空间的一棵子树，每一个域名都存在于某个区域中，TLD存在于根区域。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">www.slickghost.com 或者www.slickghost.com. 都是完全限定域名。</span><br><span class="line"></span><br><span class="line">www，slickghost，com这三个都称为标签，每个标签最多可以达到<span class="number">63</span>个字符，比如说：</span><br><span class="line">thelongestdomainnameintheworldandthensomeandthensomemoreandmore.com</span><br><span class="line"></span><br><span class="line">www是主机名，slickghost.com则是这台主机所存在的域。</span><br></pre></td></tr></table></figure></li></ul><h5 id="2-2-缓存"><a href="#2-2-缓存" class="headerlink" title="2.2.缓存"></a>2.2.缓存</h5><ul><li>域名服务器在学习域名的时候，也会缓存区域信息。使用缓存可以有效地减小网上的dns流量，也提高服务器的效率。</li><li>成功和不成功的解析（称为否定缓存，即该域名找不到对应的主机）都会被缓存。否定缓存在[RFC2308]中由可选变为强制。</li></ul><p>Windows注册表<strong>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Dnscache\Parameters</strong>控制缓存相关参数，maxcachettl为dns缓存最大TTL，dns回复中，每条记录也会有个TTL，二者取较小的值，一般都是用回复的TTL。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ipconfig /displaydns &gt; d:/dns.txt   <span class="comment">//查看本机dns缓存记录（因记录可能比较多，放在文件中查看比较合适 ）</span></span><br><span class="line">ipconfig /flushdns   <span class="comment">//清除dns缓存</span></span><br></pre></td></tr></table></figure></p><p>Linux下<strong>/etc/nscd.conf</strong>控制是否使用本地文件、DNS协议，是否要缓存，缓存TTL等</p><h3 id="三、DNS协议"><a href="#三、DNS协议" class="headerlink" title="三、DNS协议"></a>三、DNS协议</h3><p>DNS协议由两个主要部分组成</p><ul><li>对dns特定名称查询的<strong>查询/响应协议</strong></li><li>dns服务器用于<strong>交换数据库记录的协议</strong>（区域传输）<h5 id="3-1-解析过程"><a href="#3-1-解析过程" class="headerlink" title="3.1.解析过程"></a>3.1.解析过程</h5><img src="https://upload-images.jianshu.io/upload_images/12329802-ef83e17b0f52d2f8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>GW.HOME是本地DNS服务器，其使用ISP提供的DNS服务器做递归。现A.HOME查询EXAMPLE.COM最复杂的情况将经历以下11个步骤：</li></ul><p>A.HOME先查询本地hosts文件有没有EXAMPLE.COM的记录<strong>（0）</strong>，若没有，则向GW.HOME发起dns查询请求<strong>（1）</strong>，若GW.HOME不知道EXAMPLE.COM域或者COM TLD的名称服务器，他会转发查询到ISP提供的dns服务器<strong>（2）【称为递归】</strong>，假设该服务器也不知道请求的域和其他信息，则他就会联系根服务中的其中一台<strong>（3）</strong>，因为根服务器不支持递归，他看到这是一个.COM域的请求，故返回需要联系的COM TLD的名称服务器信息<strong>（4）</strong>。ISP的dns服务器联系COM TLD服务器<strong>（5）</strong>，其返回EXAMPLE.COM的名称服务器的域名和IP<strong>（6）</strong>，这里是返回了A.IANA-SERVERS.NET，接着ISP的dns服务器联系他<strong>（7）</strong>，其回复EXAMPLE.COM的相关信息<strong>（8）</strong>，ISP的dns服务器将结果发送给GW.HOME<strong>（9）</strong>，到这里，GW.HOME算完成了此次查询，可以将结果回送给A.HOME<strong>（10）</strong>。</p><h5 id="3-2-消息格式"><a href="#3-2-消息格式" class="headerlink" title="3.2.消息格式"></a>3.2.消息格式</h5><h6 id="3-2-1-消息段组成"><a href="#3-2-1-消息段组成" class="headerlink" title="3.2.1.消息段组成"></a>3.2.1.消息段组成</h6><table><thead><tr><th style="text-align:left">消息段</th><th style="text-align:left">含义 </th></tr></thead><tbody><tr><td style="text-align:left">Header</td><td style="text-align:left">头部（固定12Byte）</td></tr><tr><td style="text-align:left">Question</td><td style="text-align:left">请求（一般为1）</td></tr><tr><td style="text-align:left">Answer</td><td style="text-align:left">应答（一般至少为1）</td></tr><tr><td style="text-align:left">Authority</td><td style="text-align:left">指向域的（授权）资源记录</td></tr><tr><td style="text-align:left">Addiction</td><td style="text-align:left">其他资源记录</td></tr><tr><td style="text-align:left">Others</td><td style="text-align:left">不同类型报文有不同的信息</td></tr></tbody></table><p><img src="https://upload-images.jianshu.io/upload_images/12329802-53bd0feb007d0e70.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h6 id="3-2-2-头部字段组成"><a href="#3-2-2-头部字段组成" class="headerlink" title="3.2.2.头部字段组成"></a>3.2.2.头部字段组成</h6><table><thead><tr><th style="text-align:left">字段名</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left">Transation ID（事务ID）</td><td style="text-align:left">客户端发出查询的时候随机生成，用来匹配响应和查询。</td></tr><tr><td style="text-align:left">QR</td><td style="text-align:left">0表示查询，1表示响应。</td></tr><tr><td style="text-align:left">OpCode（操作码）</td><td style="text-align:left">标准查询（0），通知（4），更新（5），1~3被弃用。</td></tr><tr><td style="text-align:left">AA（authoritative answer，授权回答）</td><td style="text-align:left">与缓存回答相对。</td></tr><tr><td style="text-align:left">TC（truncated，可截断的）</td><td style="text-align:left">表示当前应答总长度超过512个字节，只返回前512个字节。客户端收到TC位置1的回复，可能会发送基于TCP53端口的dns请求报文，以接受能够承载多于512字节的TCP数据，因为TCP能将消息分为多个报文段。</td></tr><tr><td style="text-align:left">RD（recursion desired，期望递归）</td><td style="text-align:left">告诉服务器执行递归查询。如果这个字段为0，而收到请求的服务器没有<strong>授权回答</strong>，则被请求的名称服务器就返回一个可以联系获取回答的其他名称服务器的列表。</td></tr><tr><td style="text-align:left">RA（recursion available，递归可用）</td><td style="text-align:left">如果服务器支持递归查询，则置该字段为1。TDL和gTDL一般不支持递归查询。</td></tr><tr><td style="text-align:left">Z</td><td style="text-align:left">保留，直接置0。</td></tr><tr><td style="text-align:left">AD</td><td style="text-align:left">如果信息已授权，则AD为真。</td></tr><tr><td style="text-align:left">CD</td><td style="text-align:left">如果禁用安全检查，则CD为真。</td></tr><tr><td style="text-align:left">RCode（响应码）</td><td style="text-align:left">通常为——没有差错（0），不存在域名（3），其他错误类型可查表</td></tr></tbody></table><h6 id="3-2-3-报文分析"><a href="#3-2-3-报文分析" class="headerlink" title="3.2.3.报文分析"></a>3.2.3.报文分析</h6><p><img src="https://upload-images.jianshu.io/upload_images/12329802-084c44572c871117.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="请求报文"></p><ul><li>这是一条dns查询请求报文，QR=0（查询），RD=1（期望递归），Questions=1（查询数为1）</li><li>Queries中 ，有一条记录：</li></ul><table><thead><tr><th style="text-align:left">字段名</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left">Name</td><td style="text-align:left">要查询的域名。 其标签数为3（实际上有4个，根标签的长度为0），域名长度为15（最大长度为255）。</td></tr><tr><td style="text-align:left">Type</td><td style="text-align:left">查询类型，常见的有：<br>IPv4地址记录<strong>（A[RR类型]，1[值]）</strong><br>IPv6地址记录<strong>（AAAA，28）</strong><br> 名称服务器<strong>（NS，2）</strong><br>名称别名<strong>（CNAME，5）</strong><br>指针记录，IP映射为名称<strong>（PTR，12）</strong><br>邮件交换器<strong>（MX，15）</strong><br>文本，提供各种信息<strong>（TXT，16）</strong><br>查询开发特定服务的服务器信息<strong>（SRV，33）</strong><br>请求任意记录<strong>（ANY，255）</strong></td></tr><tr><td style="text-align:left">Class（16bit）</td><td style="text-align:left">查询类：<br>互联网类（1）<br>没有类（254）<br>所有类（255）</td></tr></tbody></table><p><img src="https://upload-images.jianshu.io/upload_images/12329802-5a5d49734b98dba5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="响应报文"></p><ul><li>这是一条dns响应报文，QR=1（响应），RD（期望递归）=1，RA（递归可用）=1。应答资源有3条，授权应答资源5条，其他应答资源2条。</li></ul><h3 id="四、常见DNS相关问题"><a href="#四、常见DNS相关问题" class="headerlink" title="四、常见DNS相关问题"></a>四、常见DNS相关问题</h3><h5 id="4-1-Anti-Spam-by-SPF"><a href="#4-1-Anti-Spam-by-SPF" class="headerlink" title="4.1.Anti-Spam by SPF"></a>4.1.Anti-Spam by SPF</h5><p>垃圾邮件伪造发件人的地址，使其看起来像一个合法的地址（如银行、官方网站等），用以欺骗收件人透露账号密码、个人资料等相关信息。而SPF（Sender Policy Framework，发送方策略框架）则是一个解决垃圾邮件和防伪造的一个标准。 许多资料上说到，PTR记录也用作电子邮件的防伪，这确实是一种方法，国外有些邮件服务器有使用到，不过比较正式的还是使用SPF来处理。</p><h6 id="4-1-1-SPF原理"><a href="#4-1-1-SPF原理" class="headerlink" title="4.1.1.SPF原理"></a>4.1.1.SPF原理</h6><ul><li><p>SPF是一种DNS记录类型，它是一种<strong>TXT</strong>记录，其登记了某个域名拥有的用来外发邮件的所有（邮件）服务器。</p></li><li><p>SPF与MX记录相反，MX是用来记录某个域名的邮件服务器有哪些，而SPF则是表面哪些邮件服务器是经过某个域名认同可以发送邮件的。</p></li></ul><p>假设一个MTA（Mail Transfer Agent）收到一条邮件，发送这条邮件的服务器IP是1.1.1.1，并声称发件人是<a href="mailto:xxx@example.com" target="_blank" rel="noopener">xxx@example.com</a>。  MTA会去查询example.com的SPF记录，该域的SPF记录允许1.1.1.1这个IP，则接受该邮件，否则视其为伪造邮件并退回。</p><h6 id="4-1-2-SPF语法"><a href="#4-1-2-SPF语法" class="headerlink" title="4.1.2.SPF语法"></a>4.1.2.SPF语法</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">linux下可以使用“dig -t txt 域名”来查看某个域名的spf记录，如：</span><br><span class="line"></span><br><span class="line">dig -t txt qq.com</span><br><span class="line">;; ANSWER SECTION:</span><br><span class="line">qq.com.1383INTXT&quot;v=spf1 include:spf.mail.qq.com -all&quot;</span><br></pre></td></tr></table></figure><p>一条SPF记录可定义一个或多个机制（mechanism）。在每一个mechanism前都有一个限定符（qualifier）对其进行评估，这些限定符包括：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">如果没有指定限定符，则默认为&quot;+&quot;</span><br><span class="line">&quot;+&quot;  Pass（通过）：发送方主机允许从该域发送邮件。</span><br><span class="line">&quot;-&quot;  Fail（拒绝）：发送方主机没有授权从该域发送邮件</span><br><span class="line">&quot;~&quot;  Soft Fail（软拒绝）：软拒绝的处理结果取决于接收电子邮件的软件。</span><br><span class="line">&quot;?&quot;  Neutral（中立）:SPF 记录中没有关于发件 IP 是否合法的信息,可接收邮件。</span><br><span class="line"></span><br><span class="line">当接收服务器处理SPF语句（使用check_host()函数）时，</span><br><span class="line">除了以上四种限定符所对应的状态外，还有三种状态，分别是：</span><br><span class="line"></span><br><span class="line">None：服务器没有设定 SPF 记录，可接收邮件。</span><br><span class="line">TempError：发生了临时错误，比如说DNS查询失败。</span><br><span class="line">PermError：SPF配置存在问题，通常是因为TXT记录或者SPF语句存在问题，没规定接收还是拒收邮件。</span><br></pre></td></tr></table></figure></p><p>接下来看看SPF的几种机制并举例：</p><ul><li><p>all ：表示所有 IP。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;v=spf1 -all&quot; 拒绝所有，这样可以表示不会以该域名发送邮件</span><br><span class="line">&quot;v=spf1 +all&quot; 接受所有</span><br></pre></td></tr></table></figure></li><li><p>ip4：格式为<strong>ip4:&lt;ip4地址&gt;</strong>或者<strong>ip4:&lt;ip4网络&gt;/&lt;掩码&gt;</strong>，用于指定一个 IPv4 地址或者地址段。如果掩码没有给出，则默认为/32。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;v=spf1 ip4:1.1.1.1 -all&quot;  只允许IP为1.1.1.1的主机</span><br></pre></td></tr></table></figure></li><li><p>ip6：类似IPv4。</p></li><li>a：指定一个a记录所对应的IP地址（段），其格式为：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a</span><br><span class="line">a/&lt;掩码&gt;</span><br><span class="line">a:&lt;域名&gt;</span><br><span class="line">a:&lt;域名&gt;/&lt;掩码&gt;</span><br><span class="line">如果没有指定域名，则默认为当前域名</span><br></pre></td></tr></table></figure></li></ul><p>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;v=spf1 a -all&quot;</span><br><span class="line">允许当前域名的 a 记录对应的 IP 地址。</span><br><span class="line">&quot;v=spf1 a a:test.example.com -all&quot;</span><br><span class="line">允许当前域名的 a 记录以及test.example.com的a记录对应的 IP 地址。</span><br></pre></td></tr></table></figure></p><ul><li>mx：和a的格式及用法一样。</li><li>exists :格式为<strong>exists:<domain></domain></strong>。对<domain>执行一个 A记录查询，只要有返回结果，就看作命中。</domain></li><li><p>include：格式为<strong>include：<domain></domain></strong>，标识引入的SPF记录和域名<domain>的SPF记录一样。</domain></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;v=spf1 include:example.com -all&quot; </span><br><span class="line">采用和 example.com 一样的 SPF 记录</span><br></pre></td></tr></table></figure></li><li><p>ptr ：格式为<strong>ptr</strong>或者<strong>ptr:<domain></domain></strong>。使用ptr机制会带来大量很大开销的 DNS 查询，官方不推荐使用。</p></li><li><p>redirect：格式为<strong>redirect=<domain></domain></strong>，表示使用<domain>域名的SPF记录替换该记录。不妨试试<strong>dig -t txt gmail.com</strong></domain></p></li></ul><h5 id="4-2-区域传输和DNS通知的用途"><a href="#4-2-区域传输和DNS通知的用途" class="headerlink" title="4.2.区域传输和DNS通知的用途"></a>4.2.区域传输和DNS通知的用途</h5><p>由于dns查询量较大，一般会使用从dns服务器分段压力。区域传输用于主dns服务器和从dns服务器之间同步RR。<br>刚开始，服务器一般使用完整的区域传输（<strong>AXFR消息</strong>），因为同步RR数据量比较大，所以通常使用TCP，传输前需建立TCP连接。在同步完成后，主服务器和从服务器共同维护一个<strong>序列号</strong>来判断当前数据库是否一致，主服务器更新了数据库之后就会增加序列号的值，从服务器定期发送自身的序列号，主服务器如果收到了较小序列号的查询，可以使用增量的区域传输（<strong>IXFR消息</strong>）让这台从服务器与自己同步。<br>因为从服务器发送查询以确认序列号是否一致是有时间间隔的，所以加入了一种<strong>DNS NOTIFY消息</strong>（基于UDP）进行优化。主服务器数据库发生变化的时候，就会发送该消息，客户端接收到该消息之后进行回复，之后就可以开始同步了。</p><h5 id="4-3-DNS劫持、污染"><a href="#4-3-DNS劫持、污染" class="headerlink" title="4.3.DNS劫持、污染"></a>4.3.DNS劫持、污染</h5><ul><li>dns劫持指的是域名服务器返回错误的ip，让请求者访问域名服务器拥有者希望其访问的页面，比较常见的就是运营商的dns劫持，最典型的就是上网时一大堆的广告。可以通过指定一个固定的dns服务器来解决。</li><li>dns污染，或者称dns缓存投毒。因为dns查询/回复一般是基于<strong>不可靠无连接</strong>的udp协议，而且通常没有什么认证机制，所以很容易被篡改。对于dns污染，我们很难通过设置来解决。不过，修改本地hosts文件是一种办法。</li></ul><h5 id="4-4-SOA和NS记录"><a href="#4-4-SOA和NS记录" class="headerlink" title="4.4.SOA和NS记录"></a>4.4.SOA和NS记录</h5><ul><li><p>SOA记录称为起始授权记录，用来表明哪个服务器是权威服务器，或者说哪个服务器是这个区域的所有者。创建dns服务器只能创建一个标准区域，通常也会使用其他服务器创建辅助区域用于分担负载等作用。创建标准区域的那台服务器就是权威服务器，即SOA记录中的ip地址是这台服务器的地址。也只有标准区域可以对信息进行更改，辅助区域只能复制信息。</p></li><li><p>NS记录是名称服务器记录，或者说是别名记录，他指明了对于某个域名，该由谁来解析。网络上有一些缓存了大量dns记录的服务器，称为<strong>唯缓存dns服务器</strong>，通过别名记录让解析权转到这样的服务器，就能够让dns解析的速度变快。我们在域名提供商申请了一个域名之后，假设是example.com，该域名提供商的域名服务器会提供此域名比如<a href="http://www.example.com的解析。如果我们自己想搭建一台dns服务器用来解析，就可以用NS记录。" target="_blank" rel="noopener">www.example.com的解析。如果我们自己想搭建一台dns服务器用来解析，就可以用NS记录。</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、作用&quot;&gt;&lt;a href=&quot;#一、作用&quot; class=&quot;headerlink&quot; title=&quot;一、作用&quot;&gt;&lt;/a&gt;一、作用&lt;/h3&gt;&lt;p&gt;现在互联网上绝大多数设备是基于TCP/IP协议，使用IP地址进行通信的。设备之间通信时必须要有一个IP地址。当我们需要访问一
      
    
    </summary>
    
      <category term="数据通信" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/"/>
    
      <category term="协议分析" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/"/>
    
    
      <category term="DNS" scheme="http://yoursite.com/tags/DNS/"/>
    
  </entry>
  
  <entry>
    <title>IP</title>
    <link href="http://yoursite.com/2018/06/02/IP/"/>
    <id>http://yoursite.com/2018/06/02/IP/</id>
    <published>2018-06-02T07:11:59.000Z</published>
    <updated>2018-10-08T03:31:12.516Z</updated>
    
    <content type="html"><![CDATA[<h5 id="1-IP头部组成"><a href="#1-IP头部组成" class="headerlink" title="1.IP头部组成"></a>1.IP头部组成</h5><p><img src="http://upload-images.jianshu.io/upload_images/12329802-3a519c9a03acb206?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>版本：IP协议的版本<ul><li>0100——IPV4</li><li>0110——IPV6 </li></ul></li><li>首部长度：ip报文的首部长度，20-60字节</li><li>服务类型：</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/12329802-33330c11c338b607?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">优先级用来区别优先级别不同的IP报文（PPP）</span><br><span class="line"></span><br><span class="line">D表示要求有更低的时延</span><br><span class="line"></span><br><span class="line">T表示要求有更高的吞吐量</span><br><span class="line"></span><br><span class="line">R表示要求有更高的可靠性</span><br><span class="line"></span><br><span class="line">C标识要求有更小的费用</span><br></pre></td></tr></table></figure><ul><li><p>总长度：报文的长度（最大65535字节）</p></li><li><p>标识：数据报长度超过MTU（最大传输单元），就要进行分片，这个标识字段的值被复制到所有数据包分片的标识字段中，使得这些分片在达到最终目的地的时候可以按照标识字段的内容重新组成原来的完整数据报。</p></li><li><p>标志：最低位MF,MF=1时，表示后面还有分片，中间位为DF,DF=1时，表示不能分片。</p></li><li><p>片偏移：本分片在原先数据报文中相对于首位的偏移位。</p></li><li><p>生存时间：表示数据报在网络中存活的时间，所允许通过的路由器最大数量。每通过一个路由器，则TTL值减少1，当其值为0时，路由器就可以把该数据包丢弃。</p></li><li><p>协议：标识上层（传输层或者是其他封装）所使用的协议。常用的协议号：</p><ul><li>ICMP 1 </li><li>IGMP 2 </li><li>TCP 6 </li><li>UDP 17 </li><li>IGRP 88 </li><li>OSPF 89</li><li>（IPv4-in-IPv4） 4</li></ul></li></ul><ul><li><p>首部校验和：对IP头部做正确性检测，不包含数据部分校验方法：在发送端，将IP数据报首部划分为多个16位的二进制序列，并将首部校验和字段置为0，用反码运算将所有16位序列对位相加后，将得到多的和的反码写入首部校验和字段。接收端接收到数据报后，将数据报首部的所有字段组织成多个16位的二进制序列，再使用反码运算相加一次，将得到的结果取反。如果结果为0代表没出错，否则出错。——具体算法实现：（待补充）</p></li><li><p>源地址和目的地址：标识了IP包的起源和目的地址。除非使用NAT，否则传输过程这两个值不变</p></li><li><p>可选项：由起源设备根据需要添加改写。</p></li><li><p>填充：IP报头长度部分的单位为32bit，所以其长度必须为32bit的整数倍，若没达到，则会填充若干个0，达到32比特。</p></li></ul><h5 id="2-IP分片"><a href="#2-IP分片" class="headerlink" title="2.IP分片"></a>2.IP分片</h5><p><img src="https://upload-images.jianshu.io/upload_images/12329802-0f810241fc31ccc5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>R1#ping 23.1.1.3 size 2000，在R2的右侧接口分析流量，可以看到数据包被分片传输</p><p><img src="https://upload-images.jianshu.io/upload_images/12329802-68ee949e148f13e0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="">  </p><p><img src="https://upload-images.jianshu.io/upload_images/12329802-8a2d8aa68c929b5c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>第一个数据帧——</p><ul><li><p>总长度为1518字节：</p><ul><li>以太网帧头14字节<ul><li>SrcMAC，6字节</li><li>detMAC，6字节</li><li>Type，2字节</li></ul></li><li>IP头部20字节</li><li>数据1480字节</li></ul></li><li><p>IP头部Flags-MF置为1，表示还有更多的分片</p></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/12329802-7d19d764eedb379e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>第二个数据帧——</p><ul><li>总长度为534字节：<ul><li>以太网帧头14字节</li><li>IP头部20字节</li><li>数据500字节</li></ul></li><li>Fragment offset为1480，即表示此分组中的数据是从第1481个字节开始的，之前的分组已经传出了1480字节的数据（不包括IP头部）</li></ul><p>两个分组的数据长度（不包括IP头）总和为1480+500=1980，第二个数据包内显示数据长度为1972字节。<br>所以R1#ping 23.1.1.3 size 2000所发送数据具体的内容应为：</p><ul><li>IP头部20字节</li><li>ICMP头部8字节</li><li>ICMP数据1972字节</li></ul><p>再来看看分片后的数据包大小（包括IP头）：  </p><ul><li>第一个数据包1500</li><li>第二个数据包520</li><li>二者总和2020字节，比原来多了20字节，即多出了一个没有填充的IP头部长度。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;1-IP头部组成&quot;&gt;&lt;a href=&quot;#1-IP头部组成&quot; class=&quot;headerlink&quot; title=&quot;1.IP头部组成&quot;&gt;&lt;/a&gt;1.IP头部组成&lt;/h5&gt;&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/uplo
      
    
    </summary>
    
      <category term="数据通信" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/"/>
    
      <category term="协议分析" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/"/>
    
    
  </entry>
  
  <entry>
    <title>ARP</title>
    <link href="http://yoursite.com/2018/06/01/ARP/"/>
    <id>http://yoursite.com/2018/06/01/ARP/</id>
    <published>2018-06-01T12:42:46.000Z</published>
    <updated>2018-10-08T03:32:23.707Z</updated>
    
    <content type="html"><![CDATA[<h5 id="1-作用"><a href="#1-作用" class="headerlink" title="1.作用"></a>1.作用</h5><ul><li><p>为什么主机需要有各自的ipv4地址和mac地址才能通信呢？<br>ip属于网络层，mac地址属于数据链路层。通过沿ip传输的路径是逻辑路径，由路由设备根据路由表进行转发，而一条逻辑路径包括多个数据链路。沿独立的数据链路传播的时候，就需要用到一种数据链路标识，以太网中的mac地址就起到这样的作用。</p></li><li><p>通常，主机刚开始发送数据的时候知道对方的ip地址，而不知道对方的mac地址。这时候就需要用到arp协议获悉到目的主机的mac地址，成功获悉到后便能正常封装数据包，并发送出去。  </p><h5 id="2-报文结构"><a href="#2-报文结构" class="headerlink" title="2.报文结构"></a>2.报文结构</h5><p><img src="https://upload-images.jianshu.io/upload_images/12329802-407deff2aa2a3930.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p></li></ul><h5 id="3-代理ARP"><a href="#3-代理ARP" class="headerlink" title="3.代理ARP"></a>3.代理ARP</h5><ul><li>代理arp被路由器作为向主机表明自身可用的一种手段：<br>当开启代理ARP的路由器接口收到一个arp请求后，会查看目的ip，是否能根据本地的路由表到达，若可到达，则将自身收到arp请求的接口的mac地址回复给请求节点，告诉其去往目的网络可往这里发送。若不可达，则无视。</li></ul><h6 id="3-1静态路由与代理arp"><a href="#3-1静态路由与代理arp" class="headerlink" title="3.1静态路由与代理arp"></a>3.1静态路由与代理arp</h6><p><img src="https://upload-images.jianshu.io/upload_images/12329802-f9d57fe0efef8b2d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>R2的g0/2接口开启代理arp功能并有返回192.168.1.0/24的静态路由</p><p>当R1使用静态路由<br>​    ip route 10.1.1.0 255.255.255.0 g0/0<br>pc0分别ping其他两台主机：</p><p><img src="https://upload-images.jianshu.io/upload_images/12329802-a25c541bf21063df.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>R1的arp表：<br><img src="https://upload-images.jianshu.io/upload_images/12329802-58451b73113baf84.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="">  </p><p>R2的g0/2口接口信息：<br><img src="https://upload-images.jianshu.io/upload_images/12329802-bb252b20c084fa00.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li><p>分析：<br>PC0 ping PC1，R1转发数据包的时候，自身arp表中没有10.1.1.1地址对应的mac地址，于是发送一条arp广播请求，R2的g0/2接口收到arp请求，由于开启了代理arp，并且拥有到达目的网络的ip，所以将自己g0/2的mac地址回复给R1（请求者）。当PC0 ping PC2的时候，依然重复此步骤。<br>故R1的arp表中，10.1.1.1与10.1.1.2所对应的mac地址都是R2的g0/2口的mac地址。（如果arp表中多个ip地址映射到单一的mac地址往往是开启了代理arp）<br>使用跟出接口的静态路由，转发每一个报文都要发送arp查询，在MA网络中，如果ARP报文大量发送，易造成广播风暴。  </p></li><li><p>若将R1的路由改为<br>  ip route 10.1.1.0 255.255.255.0 12.1.1.2  </p></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/12329802-f3d6dbbb9bf6761e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/12329802-e56cf9147db12636.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>R1转发数据包之前，会先发送arp请求查询下一跳（12.1.1.2）的mac地址，之后这条路径就无需每次都发送arp查询。  </p><h5 id="4-无故（Gratuitous）-ARP"><a href="#4-无故（Gratuitous）-ARP" class="headerlink" title="4.无故（Gratuitous） ARP"></a>4.无故（Gratuitous） ARP</h5><p>主机偶尔会以自己的IPv4地址作为目标地址发送ARP请求，此为无故ARP，或称为免费ARP。其主要有两种作用：</p><ul><li>用来检测网络中是否有ipv4地址冲突</li><li>用于通告一个新的数据链路标识符  </li></ul><p><img src="https://upload-images.jianshu.io/upload_images/12329802-a778ae1a08412f9a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>将R1的ip地址先配置为192.168.1.1/24，再配置成192.168.1.3/24。</p><p><img src="https://upload-images.jianshu.io/upload_images/12329802-c9c0e8483de022c8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>通过抓包分析可知：gratuitous arp是一个replay arp，操作码值为2，其发送者和接受者皆为自身。  路由器每次更改接口ip地址的时候，都会发送一个gratuitous arp来避免ip冲突。另外，windows和linux启动后都会发送无故arp。 </p><p>若将R2的f0/0的ip地址也改为192.168.1.3,则会出现地址冲突错误。<br><img src="https://upload-images.jianshu.io/upload_images/12329802-f6fc40fc53ab72f9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/12329802-29befa12657b7743.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""> </p><p>如果不解决这个问题，路由器会继续一直发送gratuitous arp……</p><h5 id="5-反向ARP（RARP）"><a href="#5-反向ARP（RARP）" class="headerlink" title="5.反向ARP（RARP）"></a>5.反向ARP（RARP）</h5><p>RARP作用是将数据链路标识符映射为ipv4地址，早期的无盘工作站中会使用到。不过RARP在很大程度上被DHCP和BOOTP的扩展协议所替代，他们能提供更多的信息。 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;1-作用&quot;&gt;&lt;a href=&quot;#1-作用&quot; class=&quot;headerlink&quot; title=&quot;1.作用&quot;&gt;&lt;/a&gt;1.作用&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;为什么主机需要有各自的ipv4地址和mac地址才能通信呢？&lt;br&gt;ip属于网络层，mac地址属于数据链路层
      
    
    </summary>
    
      <category term="数据通信" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/"/>
    
      <category term="协议分析" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/"/>
    
    
      <category term="ARP" scheme="http://yoursite.com/tags/ARP/"/>
    
  </entry>
  
  <entry>
    <title>LAN</title>
    <link href="http://yoursite.com/2018/05/29/LAN/"/>
    <id>http://yoursite.com/2018/05/29/LAN/</id>
    <published>2018-05-29T14:54:48.000Z</published>
    <updated>2018-10-08T03:31:45.580Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-LAN基础"><a href="#1-LAN基础" class="headerlink" title="1.LAN基础"></a>1.LAN基础</h4><ul><li><p>局域网指的是有限区域内相对距离较短的计算机和其他组件的网络，主要包含了物理层和数据链路层，一般我们接触到的局域网都是以太网组成的。</p></li><li><p>以太网发展历程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">1973年：      以太网（Xerox公司）</span><br><span class="line"></span><br><span class="line">1980年：      DIX 标准版（以太网II）【Digital Equipment Corp，Intel，Xerox】  </span><br><span class="line"></span><br><span class="line">1983年：      10 BASE-5   --&gt;10Mb/s 粗同轴电缆以太网(IEEE802.3)  </span><br><span class="line"></span><br><span class="line">1985年：      10 BASE-2   --&gt;10Mb/s 细同轴电缆以太网(IEEE802.3a)  </span><br><span class="line"></span><br><span class="line">1990年：      10 BASE-T   --&gt;10Mb/s双绞线(TP)以太网（IEEE802.3i）【twisted-pair】  </span><br><span class="line"></span><br><span class="line">1993年：      10 BASE-F   --&gt;10Mb/s光纤以太网（IEEE802.3j）【fiber】  </span><br><span class="line"></span><br><span class="line">1995年：      100 BASE-xx  --&gt; 快速以太网：100Mb/s双绞线和光纤以太网（IEEE802.3u）  </span><br><span class="line"></span><br><span class="line">1998年：      1000 BASE-X --&gt;千兆光纤以太网（IEEE802.3z）  </span><br><span class="line"></span><br><span class="line">1999年：      1000 BASE-T --&gt;千兆双绞线以太网（IEEE802.3ab）      </span><br><span class="line"></span><br><span class="line">2002年 :       10G BASE-xx  --&gt;10千兆光纤以太网（IEEE 802.3ae）     </span><br><span class="line"></span><br><span class="line">2006年 :       10G BASE-T  --&gt;10千兆双绞线以太网(IEEE 802.3an)</span><br></pre></td></tr></table></figure></li><li><p>以太网中的流量主要包括：</p><ul><li>数据流量（用户发的流量，以太网）</li><li>控制流量（交换机之间交互的流量，IEEE802.3)</li></ul></li></ul><h4 id="2-MAC地址"><a href="#2-MAC地址" class="headerlink" title="2.MAC地址"></a>2.MAC地址</h4><ul><li>MAC地址组成（烧录地址）<ul><li>24位（3字节）OUI【组织唯一标识符】+24位（3字节）厂商分配的网卡，接口。</li><li>Cisco设备：0000.0000.0000</li><li>Linux: 00:00:00:00:00:00</li><li>Windows: 00-00-00-00-00-00</li></ul></li></ul><ul><li><a href="https://www.macvendorlookup.com/" target="_blank" rel="noopener">查询设备mac地址信息</a><h4 id="3-帧格式"><a href="#3-帧格式" class="headerlink" title="3.帧格式"></a>3.帧格式</h4></li></ul><p>前导码和帧开始符无法在包嗅探程序中显示。这些信息会在OSI第1层被网卡处理掉，而不会传入嗅探程序采集数据的OSI第2层。也存在OSI物理层的嗅探工具以显示这些前导码和帧开始符，但这些设备大多昂贵，多用于检测硬件相关的故障。</p><h5 id="以太网帧格式"><a href="#以太网帧格式" class="headerlink" title="以太网帧格式"></a>以太网帧格式</h5><p><img src="https://upload-images.jianshu.io/upload_images/12329802-70170e3bb7c23a77.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>发展历程<ul><li>EthernetV1（1980），Xerox和DEC、Intel公司共同提出的标准</li><li>EthernetV2（1982），目前大部分的以太网帧都是使用这个类型</li></ul></li></ul><ul><li>Type：标识上层协议（大于<strong>0x0600</strong>）<ul><li>0x0800   ipv4</li><li>0x0806   arp</li><li>0x8100   IEEE802.1Q(dot1q)</li><li>0x86DD  ipv6</li><li>0x8864   PPPoE </li><li>0x8847   MPLSLabel </li></ul></li><li>以太网帧的长度区间为64-1518字节（6+6+2+4+[46/1500]）</li></ul><h5 id="IEEE802-3帧格式"><a href="#IEEE802-3帧格式" class="headerlink" title="IEEE802.3帧格式"></a>IEEE802.3帧格式</h5><p> <img src="https://upload-images.jianshu.io/upload_images/12329802-bbb979de7554dbe1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>802.3帧的长度区间也是64-1518字节</li><li><p>发展历程</p><ul><li><p>RAW802.3（Novell，1983）：<br>只支持IPX/SPX，将EthernetV2中的Tpye改为Length，Novell私有  </p></li><li><p>IEEE802.3/802.2 LLC（1985）：<br>IEEE正式的802.3标准，由EthernetV2发展而来，将Tpye改为Length，并且只能封装一种上层服务，即LLC，LLC子层中（通过DSAP和SSAP）区分更上层的服务。</p><ul><li><p>交换机发送BPDU使用802.3/LLC模式（DSAP和SSAP为0x42）<br><img src="https://upload-images.jianshu.io/upload_images/12329802-161b3838ddda2205.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p></li><li><p>这里使用的Length字段，表示上层数据长度</p></li></ul></li><li><p>IEEE802.3/802.2 SNAP（1985）：<br>为了在802 LLC上支持更多的上层协议同时更好的支持IP协议而发布，扩展了LLC属性，增加了一个2Byte的协议类型域（PID）和3Byte的厂商标识符（OUI）。</p><ul><li><p>VTP使用的是802.3/SNAP模式：<br><img src="https://upload-images.jianshu.io/upload_images/12329802-dd56998296701e36.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p></li><li><p>这里使用的是Tpye字段，表示上层所使用的协议</p></li></ul></li><li><p>当Tpye/Length字段小于<strong>1500,十六进制0x05DC</strong>时，对应802.3/LLC帧，当其大于<strong>1536,十六进制0x0600</strong>时，对应的是802.3/SNAP帧（与EthernetV2兼容）</p></li></ul></li><li><p>LLC中DSAP和SSAP取值不同的时候，代表不同的802.3类型帧</p><ul><li>当DSAP和SSAP都取特定值<strong>0xff</strong>时，802.3帧就变成了Netware-ETHERNET帧，用来承载NetWare（Novell的网络操作系统）类型的数据。</li><li>当DSAP和SSAP都取特定值<strong>0xaa</strong>时，802.3帧就变成了ETHERNET_SNAP帧。ETHERNET_SNAP帧可   以用于传输多种协议。（如上图VTP使用的帧类型）<ul><li>DTP——0x2004</li><li>VTP——0x2003</li><li>CDP——0x2000</li></ul></li><li>DSAP和SSAP其他的取值均为IEEE802.3/LLC帧。（如BPDU使用的帧类型）</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1-LAN基础&quot;&gt;&lt;a href=&quot;#1-LAN基础&quot; class=&quot;headerlink&quot; title=&quot;1.LAN基础&quot;&gt;&lt;/a&gt;1.LAN基础&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;局域网指的是有限区域内相对距离较短的计算机和其他组件的网络，主要包含了物理层和数据
      
    
    </summary>
    
      <category term="数据通信" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/"/>
    
      <category term="基本概念" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    
    
      <category term="LAN" scheme="http://yoursite.com/tags/LAN/"/>
    
  </entry>
  
</feed>
